///////////////////////////////////////////////////////////////////////////////
///  TGraph.h
///  <TODO: insert file description here>
///
///  @remarks <TODO: insert remarks here>
///
///  @author Yan Qi @date 5/29/2010
/// 
/// $Id$
///////////////////////////////////////////////////////////////////////////////
#pragma once

template<typename T>
class TGraph
{
public: // members

	const static double DISCONNECT; 
	
	typedef GVertex<T> TVertex;

protected: // members

	std::map<TVertex*, std::set<TVertex*> > m_mpFanoutVertices;
	std::map<TVertex*, std::set<TVertex*> > m_mpFaninVertices;
	std::map<int, double> m_mpEdgeCodeWeight; 
	//std::set<T> m_stVertices;
	std::map<T, TVertex*> m_mpVertexIndex;
	std::vector<TVertex*> m_vtVertices;
	int m_nEdgeNum;
	int m_nVertexNum;


public: // methods

	virtual ~TGraph(void){clear();}

	void clear()
	{
		m_nEdgeNum = 0;
		m_nVertexNum = 0;

		m_mpFanoutVertices.clear();
		m_mpFaninVertices.clear();

		m_mpEdgeCodeWeight.clear();

		/*m_stVertices.clear();*/
		m_mpVertexIndex.clear();

		//clear the list of vertices objects
		for_each(m_vtVertices.begin(), m_vtVertices.end(), DeleteFunc<GIntVertex>());
		m_vtVertices.clear();
	}
	
protected: // methods

	int get_edge_code(const TVertex* start_vertex_pt, const TVertex* end_vertex_pt) const
	{
		/// Note that the computation below works only if 
		/// the result is smaller than the maximum of an integer!
		return start_vertex_pt->getID()*m_nVertexNum+end_vertex_pt->getID();
	}

public: 

	double get_edge_weight(const TVertex* start_vertex_pt, const TVertex* end_vertex_pt) const
	{
		std::map<int, double>::const_iterator pos = 
			m_mpEdgeCodeWeight.find(get_edge_code(start_vertex_pt, end_vertex_pt));
		
		if (pos != m_mpEdgeCodeWeight.end())
		{
			return pos->second;
		}

		return DISCONNECT;
	}

	TVertex* get_vertex_by_ID(int id) const
	{
		return m_vtVertices.at(id);
	}

	TVertex* get_vertex(T node_)
	{
		TVertex* vertex_pt = NULL;
		const std::map<T, TVertex*>::iterator pos = m_mpVertexIndex.find(node_);
		if (pos == m_mpVertexIndex.end())
		{
			int vertex_id = m_vtVertices.size();
			vertex_pt = new TVertex(node_);
			vertex_pt->setID(vertex_id);
			m_vtVertices.push_back(vertex_pt);
			m_mpVertexIndex.insert(make_pair(node_, vertex_pt));
		}else
		{
			vertex_pt = m_vtVertices.at(pos->second->getID());
		}

		return vertex_pt;
	}

    const std::set<TVertex*> get_precedent_vertex_set(TVertex* vertex) 
	{
		return get_vertex_set(vertex, m_mpFaninVertices);
	}

	const std::set<TVertex*> get_adjacent_vertex_set(TVertex* vertex) 
	{
		return get_vertex_set(vertex, m_mpFanoutVertices);
	}

	
	///////////////////////////////////////////////////////////////////////////////
	///  inline protected  get_vertex_set
	///		The implementation could be improved through changing the returning type. 
	///
	///  @param [in, out]  vertex_ TGraph<T>::TVertex *    <TODO: insert parameter description here>
	///  @param [in]       vertex_container_index std::map<TVertex*,std::set<TVertex*> >    <TODO: insert parameter description here>
	///
	///  @return std::set<TVertex*> <TODO: insert return value description here>
	///
	///  @remarks <TODO: insert remarks here>
	///
	///  @see <TODO: insert text here>
	///
	///  @author Yan Qi @date 5/30/2010
	///////////////////////////////////////////////////////////////////////////////
	/////// comment generated by CommentMakerPro from www.FeinSoftware.com ////////
	std::set<TVertex*> get_vertex_set(TVertex* vertex_, 
		std::map<TVertex*, std::set<TVertex*> > vertex_container_index)
	{
		std::map<TVertex*, std::set<TVertex*> >::iterator pos = 
			vertex_container_index.find(vertex_);

		if(pos == vertex_container_index.end())
		{
			std::set<TVertex*> vertex_set;
			pair<std::map<TVertex*, std::set<TVertex*> >::iterator,bool> ins_pos = 
				vertex_container_index.insert(make_pair(vertex_, vertex_set));

			pos = ins_pos.first;
		}
	
		return pos->second;
	}

};

template<typename T>
const double TGraph<T>::DISCONNECT = (numeric_limits<double>::max)();